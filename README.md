# leetcode刷题总结(C++)


# 1 basics
## 1.1 data structure

### vector

### string

### deque

### list

### set

### map

## 1.2 search algorithm

### 

## 1.3 sort algorithm

| sort algorithm | time complex(ave) | time complex(worst) | time complex(best) | space complex | stability |
| :------: | :------: | :------: | :------: | :------: | :------: | 
| 冒泡排序 | O(n^2) | O(n^2) | O(n) | O(1) | 稳定 |
| 快速排序 | O(nlogn) | O(n^2) | O(nlogn) | O(nlogn) | 不稳定 |
| 插入排序 | O(n^2) | O(n^2) | O(n) | O(1) | 稳定 |
| 希尔排序 | O(nlogn) | O(n^1.5) | 增量序列决定 | O(1) | 不稳定 |
| 选择排序 | O(n^2) | O(n^2) | O(n^2) | O(1) | 不稳定 |
| 堆排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(1) | 不稳定 |
| 归并排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(n) | 稳定 |
| 计数排序 | O(n^2) | O(n^2) | O(n) | O(n+k) | 稳定 |
| 桶排序 | O(n^2) | O(n^2) | O(n) | O(n+k) | 稳定 |
| 基数排序 | O(n^2) | O(n^2) | O(n) | O(n+k) | 稳定 |


# 2 leetcode problem

## 2.1 Array

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.2 Dynamic programming

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.3 String

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.4 Math

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.5 Tree

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.6 Hash table

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.7 Deep-first search

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.8 Binary search

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.9 Binary search

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.10 Two pointers

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.11 Breadth-first search

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.12 Greedy

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |
