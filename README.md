# leetcode刷题总结(C++)


# 1 basics
## 1.1 data structure

- ### vector


vector是封装动态数组的顺序容器，元素顺序存储，可以通过迭代器和指针访问元素。vector在内存中是自动管理的，按需扩张和收缩。通常占用多于静态数组的空间，以便分配更多内存用于管理将来的增长，占用空间在额外内存即将耗尽时重新分配。

基础API

```c++
<<<<<<< HEAD
#include <iostream>
#include <vector>

using namespace std;
=======
include <vector>
>>>>>>> fa216d285cbe33bdddefd7a2c7fb8310da44dd82

//构造函数
vector<int> vec1; //无参数
vector<int> vec2(3); //n个元素
vector<int> vec3(3,5); //n个val值
vevtor<int> vec4(vec3); //vector对象
vector<int> vec5(vec3.begin(), vec3.end()); //迭代器

<<<<<<< HEAD
//元素访问
cout << vec1[0] << endl; //[]下标访问
cout << vec1.at(0) << endl; //at()下标访问，有越界检查
cout << vec1.front() << endl; //第一个元素
cout << vec1.back() << endl; //最后一个元素

//元素增删
vec1.push_back(3); //将元素添加到末尾
vec1.pop_back(); //移除末尾元素，没有返回值
vec1.insert(vec1.begin(), 3); //在迭代器位置前插入元素，注意insert可能导致迭代器非法话

//属性
cout << vec1.empty() << endl; //返回是否为空
cout << vec1.size() << endl; //容纳元素数量
cout << vec1.capacity() << endl; //占用存储空间可容纳元素数量
```

- ### string

  

- ### deque
=======
//
```


>>>>>>> fa216d285cbe33bdddefd7a2c7fb8310da44dd82

  

- ### list

  

- ### set

  

- ### map

  

## 1.2 search algorithm

| search algorithm | 查找复杂度 | 插入复杂度 | 删除复杂度 | space complex |
| :------: | :------: | :------: | :------: | :------: |
| 顺序查找 | O(n/2) | O(n) | O(n/2) | O(1) |
| 二分查找 | O(logn) | O(n/2) | O(n/2) | O(nlogn) |
| 插值查找 | O(log(logn)) | O(n^2) | O(n) | O(1) |
| 二叉查找树 | O(logn) | O(logn) | O(n^0.5) | O(1) |
| 2-3树 | O(clogn) | O(clogn) | O(clogn) | O(1) |
| 红黑树 | O(logn) | O(logn) | O(logn) | O(1) |
| B树 | O(logn) | O(logn) | O(logn) | O(n) |
| 哈希函数 | O(1) | O(1) | O(1) | O(1) |

## 1.3 sort algorithm

| sort algorithm | time complex(ave) | time complex(worst) | time complex(best) | space complex | stability |
| :------: | :------: | :------: | :------: | :------: | :------: |
| 冒泡排序 | O(n^2) | O(n^2) | O(n) | O(1) | 稳定 |
| 快速排序 | O(nlogn) | O(n^2) | O(nlogn) | O(nlogn) | 不稳定 |
| 插入排序 | O(n^2) | O(n^2) | O(n) | O(1) | 稳定 |
| 希尔排序 | O(nlogn) | O(n^1.5) | 增量序列决定 | O(1) | 不稳定 |
| 选择排序 | O(n^2) | O(n^2) | O(n^2) | O(1) | 不稳定 |
| 堆排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(1) | 不稳定 |
| 归并排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(n) | 稳定 |
| 计数排序 | O(n+k) | O(n+k) | O(n+k) | O(n+k) | 稳定 |
| 桶排序 | O(n+k) | O(n+k) | O(n+k) | O(n+k) | 稳定 |
| 基数排序 | O(n) | O(n) | O(n) | O(n) | 稳定 |


# 2 leetcode problem

## 2.1 Array

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.2 Dynamic programming

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.3 String

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.4 Math

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.5 Tree

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.6 Hash table

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.7 Deep-first search

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.8 Binary search

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.9 Binary search

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.10 Two pointers

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.11 Breadth-first search

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.12 Greedy

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |
