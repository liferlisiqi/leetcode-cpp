# leetcode刷题总结(C++)


# 1 basics
## 1.1 data structure

- ### vector


vector是封装动态数组的顺序容器，元素顺序存储，可以通过迭代器和指针访问元素。vector在内存中是自动管理的，按需扩张和收缩。通常占用多于静态数组的空间，以便分配更多内存用于管理将来的增长，占用空间在额外内存即将耗尽时重新分配。

基础API

```c++
#include <iostream>
#include <vector>

using namespace std;

//构造函数
vector<int> vec1; //无参数
vector<int> vec2(3); //n个元素
vector<int> vec3(3,5); //n个val值
vevtor<int> vec4(vec3); //vector对象
vector<int> vec5(vec3.begin(), vec3.end()); //迭代器

//元素访问
cout << vec1[0] << endl; //[]下标访问
cout << vec1.at(0) << endl; //at()下标访问，有越界检查
cout << vec1.front() << endl; //第一个元素
cout << vec1.back() << endl; //最后一个元素

//元素增删
vec1.push_back(3); //将元素添加到末尾
vec1.pop_back(); //移除末尾元素，没有返回值
vec1.insert(vec1.begin(), 3); //在迭代器位置前插入元素，注意insert可能导致迭代器非法话

//属性
cout << vec1.empty() << endl; //返回是否为空
cout << vec1.size() << endl; //容纳元素数量
cout << vec1.capacity() << endl; //占用存储空间可容纳元素数量
```

- ### string

c++从c继承的字符串概念仍然是以 '\0' 为结束符的char数组，STL中的std::string是std::basic_string的一个特化，可以将字符串作为一个类型，实现复制、赋值和比较等操作，不必担心内存大小和占用内存实际长度等具体问题。

基础API

```c++
#include<iostream>
#include<string>
#include<sstream>

using namespace std;

//构造函数
string str1; //无参初始化
string str2 = "abc"; //最简单的字符串初始化
char *s = "abc";
string str3(s); //用c字符串初始化
string str4(3, 'c'); //用n个字符初始化
string str5(str4); //全部复制

//标准输入
cin >> str1; //读取以空格或回车为结尾的字符序列
cout << str1 <<endl;
getline(cin, str1); //读取整行的字符，遇到分界符、回车符、文件结束符时终止操作
cout << str1 << endl;
getline(cin, str1, " "); //参数3指定分界符
cout << str1 << endl;

//元素访问
cout << str1[0] << endl; //[]返回下标位置的字符
cout << str1.at(0) << endl; //at()返回下标位置字符，提供越界检查，超出范围抛出out_of_range异常
cout << str1.front() << endl; //返回第一个字符
cout << str1.back() << endl; //返回最后一个字符
cout << str1.c_str() << endl; //返回c字符数组

//属性
cout << str1.empty() << endl; //字符串是否未空
cout << str1.size() << " " << str1.length() << endl; //字符串长度

//增，三种方法: +=, push_back, append，建议基础操作使用+=,复杂操作使用append
cout << str2 + "def" << endl; //使用+号增加字符串
cout << str2 + 'd' + 'e' + 'f' << endl; //使用+号增加字符
str2 += {'d', 'e', 'f'};
cout << str2 << endl; //使用+号增加

str2.push_back('d'); //push_back只能在结尾添加一个字符，功能单一
str2.push_back('e');
str2.push_back('f');

str2.append("def");
str2.append(3, 'd');
str2.append(s);

//查，
str3 += "bc";
cout << str3.find('a') << endl; //find()寻找首个等于给定 字符序列 的字串
cout << str3.find("bc") << endl; 
cout << str3.find_first_of("bc") << endl; //find_first_of()寻找等于给定字符序列中字符之一的首个字符                                      
```



[std::string::append vs std::string::push_back() vs Operator += in C++](https://www.geeksforgeeks.org/stdstringappend-vs-stdstringpush_back-vs-operator-c/)



- ### deque


deque（双端队列）是有下标顺序容器，允许在首尾两端快速地插入及删除，且不会非法化指向其他元素的指针或引用。deque的元素不是相接存储的，典型的实现是用单独分配的固定大小数组序列，外加额外的登记，所以下标访问需要二次指针解引用。

基础API

```c++
#include<iostream>
#include<deque>

using namespace std;



```





- ### list




- ### set




- ### map

  



## 1.2 search algorithm 查找算法

| 查找算法 | 查找复杂度（平均/最坏） | 插入复杂度（平均/最坏） | 删除复杂度（平均/最坏） | 空间复杂度 |
| :------: | :------: | :------: | :------: | :------: |
| 顺序查找 | O(n/2) | O(n) | O(n/2) | O(1) |
| 二分查找 | O(logn) | O(n/2) | O(n/2) | O(nlogn) |
| 插值查找 | O(log(logn)) | O(n^2) | O(n) | O(1) |
| 二叉查找树 | O(logn) | O(logn) | O(n^0.5) | O(1) |
| 2-3树 | O(clogn) | O(clogn) | O(clogn) | O(1) |
| 红黑树 | O(logn) | O(logn) | O(logn) | O(1) |
| B树 | O(logn) | O(logn) | O(logn) | O(n) |
| 哈希函数 | O(1) | O(1) | O(1) | O(1) |

## 1.3 sort algorithm 排序算法

| 排序算法 | 平均时间复杂度 | 最坏时间复杂度 | 最好时间复杂度 | 空间复杂度 | 稳定性 |
| :------: | :------: | :------: | :------: | :------: | :------: |
| 冒泡排序 | O(n^2) | O(n^2) | O(n) | O(1) | 稳定 |
| 快速排序 | O(nlogn) | O(n^2) | O(nlogn) | O(nlogn) | 不稳定 |
| 插入排序 | O(n^2) | O(n^2) | O(n) | O(1) | 稳定 |
| 希尔排序 | O(nlogn) | O(n^1.5) | 增量序列决定 | O(1) | 不稳定 |
| 选择排序 | O(n^2) | O(n^2) | O(n^2) | O(1) | 不稳定 |
| 堆排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(1) | 不稳定 |
| 归并排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(n) | 稳定 |
| 计数排序 | O(n+k) | O(n+k) | O(n+k) | O(n+k) | 稳定 |
| 桶排序 | O(n+k) | O(n+k) | O(n+k) | O(n+k) | 稳定 |
| 基数排序 | O(n) | O(n) | O(n) | O(n) | 稳定 |


# 2 leetcode problem

## 2.1 Array

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.2 Dynamic programming

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.3 String

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.4 Math

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.5 Tree

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.6 Hash table

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.7 Deep-first search

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.8 Binary search

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.9 Binary search

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.10 Two pointers

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.11 Breadth-first search

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |


## 2.12 Greedy

| 题目 | Tag | 难度 | 题解 |
| :------: | :------: | :------: | :------: |
| 最优页面置换算法（OPT） | 置换在未来最长时间不访问的页面 | 计算内存中每个逻辑页面的下次访问时间，选择未来最长时间不访问的页面 | 缺页最少，理想情况，无法实现，可作为性能评价依据 |
